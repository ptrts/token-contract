var source = "pragma solidity ^0.4.13;\n\n\/\/ Это интерфейс для тех контрактов, которым покупатель токена может выдать разрешение на трату его токенов\n\/\/ У таких контрактов может быть метод, для уведомления их о том, что им дано право тратить токены\ncontract TokenRecipient {\n\n    \/\/ Получить разрешение на трату чьих-то чужих токенов какого-то вида\n    function receiveApproval(\n\n    \/\/ Кто дал тебе такое разрешение, и с чьего счета ты сможешь теперь тратить токены\n    address _from,\n\n    \/\/ Сколько токенов ты можешь потратить\n    uint256 _value,\n\n    \/\/ Адрес контракта, обслуживающего данный вид токенов\n    address _token,\n\n    \/\/ Какие-то дополнительные данные, которые владелец счета с токенами приложил к своему разрешению \n    bytes _extraData\n    );\n}\n\ncontract Owned {\n\n    address public owner;\n\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract TokenContract is Owned {\n\n    \/\/ Публичные переменные контракта.\n\n    \/\/ Каждый сможет узнать их значения.\n\n    uint256 public sellPrice;\n    uint256 public buyPrice;\n\n    \/\/ Версия интерфейса токена\n    string public standard = 'Token 0.1';\n\n    \/\/ Название токена\n    string public name;\n\n    \/\/ Символ токена\n    string public symbol;\n\n    \/\/ Сколько точек после запятой у самой маленькой допустимой дольки этого токена\n    uint8 public decimals;\n\n    \/\/ Сколько сейчас этого токена всего\n    uint256 public totalSupply;\n\n    \/\/ Функция для получения баланса\n    mapping (address => uint256) public balanceOf;\n\n    \/\/ Функция для получения подбалансов для друзей того счета, у которого есть баланс\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    \/\/ Событие в логе о том,что произошел перевод средств: кто, кому, сколько\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    \/\/ Событие о том, что некто потратил какое-то количество токенов\n    event Burn(address indexed from, uint256 value);\n\n    \/\/ Функция создания контракта\n    \/\/ Указывается не только количество токенов, но и отличительные характеристики токена\n    \/\/ Вопрос. Мы этот контракт будем компилировать и деплоить какой-то транзакцией. \n    \/\/ Где мы будем указывать параметры для этой функции? Это при компиляции? Это при деплое? \n    \/\/ Как конкретно указывать эти значения?\n    function TokenContract(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        uint256 _sellPrice,\n        uint256 _buyPrice\n    ) {\n        owner = msg.sender;\n\n        \/\/ Переводим изначальное количество токена на создателя\n        balanceOf[this] = initialSupply;\n\n        \/\/ Устанавливаем переменную с изначальным запасом\n        totalSupply = initialSupply;\n\n        name = tokenName;\n        symbol = tokenSymbol;\n        decimals = decimalUnits;\n\n        sellPrice = _sellPrice;\n        buyPrice = _buyPrice;\n    }\n\n    \/\/ Перевести свои токены на другой счет\n    function transfer(address _to, uint256 _value) {\n\n        \/\/ Если некто пытается перевести на пустой счет, то выбросить исключение\n        require(_to > 0x0);\n\n        \/\/ Проверить, есть ли у отправителя столько токенов\n        require(balanceOf[msg.sender] >= _value);\n\n        \/\/ Проверяем не переполнится ли счет-назначение, если мы переведем на него такую сумму\n        \/\/ Прибавляем к балансу счета-назначения указанную сумму, и если она стала не больше, а меньше, \n        \/\/ то это значит, что произошло переполнение\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n\n        \/\/ Отнимаем сумму со счета отправителя\n        balanceOf[msg.sender] -= _value;\n\n        \/\/ Прибавляем сумму к счету получателя\n        balanceOf[_to] += _value;\n\n        \/\/ Записываем в лог событие, что произошло перечисление денег\n        Transfer(msg.sender, _to, _value);\n    }\n\n    \/\/ Владелец счета добавляет разрешение другому счету тратить токены, в пределах какого-то максимума\n    \/\/ Владелец как бы открывает внутри своего счета токенов, еще один счет токенов, для другого участника сети\n    \/\/ По интерфейсу, этот метод должен возвращать флаг успешности\n    \/\/ Наша реализация всегда возвращает true\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    \/\/ Владелец счета дает разрешение другому участнику сети на трату токенов с его счета\n    \/\/ Причем, счет другого участника сети - это контракт, у которого есть метод, через который его можно уведомить, \n    \/\/ что теперь он может тратить\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n\n        \/\/ Удостовериться, что контракт другого участника сети поддерживает уведомления о праве тратить токены\n        TokenRecipient spender = TokenRecipient(_spender);\n\n        \/\/ Дать разрешение на трату токенов\n        if (approve(_spender, _value)) {\n\n            \/\/ Уведомить, что дано разрешение на трату токенов\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n\n            return true;\n        }\n    }\n\n    \/\/ Некто, кому владелец некого счета дал разрешение тратить свои токены, \n    \/\/ хочет перевести эти токены на какой-то другой счет\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n        \/\/ Проверяем, чтобы не переводили на нулевой счет\n        require(_to > 0x0);\n\n        \/\/ Проверяем, есть ли на счету столько денег\n        require(balanceOf[_from] >= _value);\n\n        \/\/ Проверяем, не лопнет ли счет получателя\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n\n        \/\/ Проверяем, можно ли инициатору данной функции тратить столько денег\n        require(_value <= allowance[_from][msg.sender]);\n\n        \/\/ Вычитаем токены со счета\n        balanceOf[_from] -= _value;\n\n        \/\/ Добавляем токены на счет получателя\n        balanceOf[_to] += _value;\n\n        \/\/ Вычитаем токены из токенов, которые инициатору разрешено тратить с этого счета\n        allowance[_from][msg.sender] -= _value;\n\n        \/\/ Записываем в лог, что произошла передача данных\n        Transfer(_from, _to, _value);\n\n        \/\/ Сообщаем, что все закончилось хорошо\n        return true;\n    }\n\n    \/\/ Владелец счета хочет потратить свои средства\n    function burn(uint256 _value) returns (bool success) {\n\n        \/\/ Проверяем, есть ли у него столько токенов\n        require(balanceOf[msg.sender] >= _value);\n\n        \/\/ Вычитаем указанное количество токенов с его счета\n        balanceOf[msg.sender] -= _value;\n\n        \/\/ Уменьшаем общее количество токенов\n        totalSupply -= _value;\n\n        \/\/ Записываем в лог трату токенов\n        Burn(msg.sender, _value);\n\n        return true;\n    }\n\n    \/\/ Доверенное лица владельца хочет потратить токены владельца\n    function burnFrom(address _from, uint256 _value) returns (bool success) {\n\n        \/\/ Проверяем, есть ли у хозяина столько токенов\n        require(balanceOf[_from] >= _value);\n\n        \/\/ Проверяем, разрешено ли доверенному лицу столько тратить\n        require(_value <= allowance[_from][msg.sender]);\n\n        \/\/ Вычитаем со счета владельца\n        balanceOf[_from] -= _value;\n\n        \/\/ Уменьшаем общее количество токенов\n        totalSupply -= _value;\n\n        \/\/ Записываем в лога трату токенов\n        Burn(_from, _value);\n\n        \/\/ Возвращаем, что все прошло хорошо\n        return true;\n    }\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n\n        \/\/ Добавить кому-то токенов\n        balanceOf[target] += mintedAmount;\n\n        \/\/ Добавить общее количество токенов\n        totalSupply += mintedAmount;\n\n        \/\/ Записать в лог, что произошел перевод денег из ниоткуда на владельца контракта\n        Transfer(0, this, mintedAmount);\n\n        \/\/ Записать в лог перемещение денег от владельца на того, на кого хочешь выпустить\n        if (target != address(this)) {\n            Transfer(this, target, mintedAmount);\n        }\n    }\n\n    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {\n        sellPrice = newSellPrice;\n        buyPrice = newBuyPrice;\n    }\n\n    function() payable onlyOwner {\n    }\n\n    \/\/ Некто прислал нам эфиров, чтобы купить на них токены, по текущей цене\n    function buyOnBehalfOf(address buyer) payable returns (uint amount) {\n        \n        require(buyer > 0x0);\n    \n        \/\/ К нам в транзакцию пришло какое-то количество эфиров\n        \/\/ К этому количеству эфиров мы имеем доступ через такое свойство:\n        \/\/      msg.value\n    \n        \/\/ Выясняем, на сколько эфиров хватит того количества эфиров, которое нам прислали\n        amount = msg.value \/ buyPrice;\n\n        \/\/ Продавать мы будем токены, которые принадлежат самому контракту\n        \/\/ Не владельцу контракта, а прямо самому контракту\n\n        \/\/ Проверяем, что на контракте числится достаточно токенов для покупки\n        require(amount <= balanceOf[this]);\n\n        \/\/ Добавляем покупателю токенов\n        balanceOf[buyer] += amount;\n\n        \/\/ Вычитаем токены, принадлежащие самому контракту\n        balanceOf[this] -= amount;\n\n        \/\/ Записываем в лог событие перевода токенов\n        Transfer(this, buyer, amount);\n\n        \/\/ Возвращаем купленное количество токенов\n        return amount;\n    }\n\n    \/\/ Некто просит забрать его токены и выслать ему эфиров, в соответствии с текущей ценой продажи\n    function sell(uint amount) returns (uint revenue){\n\n        \/\/ Проверяем, что у автора сообщения есть столько токенов, сколько он хочет продать  \n        require(amount <= balanceOf[msg.sender]);\n\n        \/\/ Добавляем эти токены на счет самого контракта\n        balanceOf[this] += amount;\n\n        \/\/ Вычитаем токены со счета автора сообщения\n        balanceOf[msg.sender] -= amount;\n\n        \/\/ Вычисляем количество эфиров, которые мы ему теперь должны\n        revenue = amount * sellPrice;\n\n        \/\/ sends ether to the seller: it's important\n        require(msg.sender.send(revenue));\n\n        \/\/ executes an event reflecting on the change\n        Transfer(msg.sender, this, amount);\n\n        \/\/ ends function and returns\n        return revenue;\n    }\n}\n\ncontract Proxy {\n\n    TokenContract public tokenContract;\n\n    string public proxyName;\n\n    function Proxy(\n        TokenContract _tokenContract,\n        string _proxyName\n    ) {\n        tokenContract = _tokenContract;\n        proxyName = _proxyName;\n    }\n\n    function() payable {\n        tokenContract.buyOnBehalfOf.value(msg.value)(msg.sender);\n    }\n}";
var solFile = "/home/ptaruts/tasks/technologies/etherium/projects/token-contract/token-proxy-system.sol";
var contractName = "TokenContract";
